package is.hail.expr.ir

import is.hail.expr.types.virtual.{TArray, TStream, TStreamable}

object LowerArrayToStream {
  private[this] def streamify(streamableNode: IR): IR = streamableNode match {
    case _: MakeStream | _: StreamRange | _: ReadPartition => Copy(streamableNode, Children(streamableNode).map { case c: IR => apply(c) } )
    case ArrayRange(start, stop, step) => {
      println("hit array range")
      StreamRange(apply(start), apply(stop), apply(step))
    }
    case MakeArray(args, t) => MakeStream(args.map(apply), TStream(t.elementType, t.required))
    case ArrayMap(a, n, b) =>
      if (a.typ.isInstanceOf[TStream]) streamableNode
      else ArrayMap(streamify(a), n, apply(b))
    case ArrayFilter(a, n, b) =>
      if (a.typ.isInstanceOf[TStream]) streamableNode
      else ArrayFilter(streamify(a), n, apply(b))
    case ArrayFlatMap(a, n, b) =>
      if (a.typ.isInstanceOf[TStream] && b.typ.isInstanceOf[TStream]) streamableNode
      else ArrayFlatMap(streamify(a), n, streamify(b))
    case ArrayScan(a, zero, zn, an, body) =>
      if (a.typ.isInstanceOf[TStream]) streamableNode
      else ArrayScan(streamify(a), apply(zero), zn, an, apply(body))
    case ToArray(a) =>
      println("in streamify toArray")
      a.typ match {
        case _: TStream => a
        case _: TArray => streamify(a)
        case _ => ToStream(apply(streamableNode))
      }
    case ToStream(a) =>
      a.typ match {
        case _: TStream => a
        case _ => ToStream(apply(a))
      }
    case ArrayLeftJoinDistinct(l, r, ln, rn, keyf, joinf) =>
      ArrayLeftJoinDistinct(streamify(l), streamify(r), ln, rn, apply(keyf), apply(joinf))
    case Let(n, v, b) =>
      Let(n, apply(v), streamify(b))
    case _ =>
      ToStream(Copy(streamableNode, Children(streamableNode).map { case c: IR => apply(c) } ))
  }

  private[this] def unstreamify(streamableNode: IR): IR = streamableNode match {
    case ToArray(a) =>
      println(s"CALLED unstreamify TOARRAY ON ${a}")
      a.typ match {
        case _: TArray => ToArray(streamify(a))
        case _ => streamableNode
      }
    case ToStream(a) =>
      a.typ match {
        case _: TStream => ToArray(a)
        case _ => a
      }
    case If(cond, cnsq, altr) =>
      If(cond, unstreamify(cnsq), unstreamify(altr))
    case Let(n, v, b) =>
      Let(n, v, unstreamify(b))
    case _ =>
      streamify(streamableNode) match {
        case ToStream(a) if !a.typ.isInstanceOf[TStream] => a
        case s => ToArray(s)
      }
  }

  def apply(node: IR): IR = {
    println(s"The array received by LowerArrayToStream in Arcturus version: ${node}")
    val r = node match {
      case ArraySort(a, l, r, comp) => ArraySort(streamify(a), l, r, comp)
      case ToSet(a) => ToSet(streamify(a))
      case ToDict(a) => ToDict(streamify(a))
      case ArrayFold(a, zero, zn, an, body) => ArrayFold(streamify(a), zero, zn, an, body)
      case ArrayFor(a, n, b) => ArrayFor(streamify(a), n, b)
      case ArrayAgg(a, name, query) => ArrayAgg(streamify(a), name, query)
      case ArrayZip(childIRs, names, body, behavior) =>
        ToArray(ArrayZip(childIRs.map(streamify), names, body, behavior))
      case ArrayAggScan(a, n, q) => ArrayAggScan(streamify(a), n, q)
      case x: ApplyIR => apply(x.explicitNode)
      case If(c, t, e) => If(c, apply(t), apply(e))
      case _ if node.typ.isInstanceOf[TStreamable] => unstreamify(node)
      case _ => Copy(node, Children(node).map { case c: IR => apply(c) })
    }

    println(s"The array generated by LowerArrayToStream in Arcturus version: ${r}")
    r
  }
//  def apply(node: IR): IR = {
//    println(s"IN lower for ${ node }")
//    val r = node match {
//      case NA(t: TStreamable) => NA(TStream(t.elementType, t.required))
//      case MakeArray(xs, t) => MakeStream(xs, TStream(t.elementType, t.required))
//      case ArrayRange(x, y, z) => StreamRange(x, y, z)
//      case ArrayMap(a, n, b) => ToArray(ArrayMap(apply(a), n, b))
//      case ArrayZip(as, ns, b, behavior) => ArrayZip(as.map(apply), ns, b, behavior)
//      case ArrayFilter(a, n, b) => ArrayFilter(apply(a), n, b)
//      case ArrayFlatMap(a, n, b) => ToArray(ArrayFlatMap(apply(a), n, apply(b)))
//      case ArrayLeftJoinDistinct(l, r, ln, rn, c, j) => ArrayLeftJoinDistinct(apply(l), apply(r), ln, rn, c, j)
//      case ArrayScan(a, z, an, en, b) => ArrayScan(apply(a), z, an, en, b)
//      case ArrayAggScan(a, n, q) => ArrayAggScan(apply(a), n, q)
//      case RunAggScan(a, name, init, seq, res, sig) => RunAggScan(apply(a), name, init, seq, res, sig)
//      case Let(n, v, b) => Let(n, v, apply(b))
//      case If(c, t, e) => If(c, apply(t), apply(e))
//      case x: ReadPartition => x
//      case MakeTuple(fields) =>
//        MakeTuple(fields.map(f => (f._1, apply(f._2))))
//      case _ => {
//        if(node.typ.isInstanceOf[TStream])
//          node
//        else
//          ToStream(node)
//      }
//    }
//
//  println(s"The array generated by LowerArrayToStream in my shitty version: ${r}")
//    r
//  }
}
// Except, some of these things have children that need to be streamify'd
// things that call emitArrayIterator
// For instance, we will encounter MakeStruct, with a bunch of fields
// ArrayAgg
// CollectDistributedArray
// ArraySort
// ToSet
// ToDict
// ArrayMap | _: ArrayZip | _: ArrayFilter | _: ArrayRange | _: ArrayFlatMap | _: ArrayScan | _: ArrayLeftJoinDistinct | _: RunAggScan | _: ArrayAggScan | _: ReadPartition
// ArrayFold
// ArrayFold2
// ArrayFor
// ArrayAgg
// RunAgg

//  def streamify(ir: IR): IR = {
//    println(s"RUNNING on ${ir}!")
//
//    val newIR = ir match {
//      // nodes that take arrays pre-lowering, and need streams post-lowering
////      case ArrayAgg(a, name, query) => ArrayAgg(toStream(a), name, query)
////      case ArrayFor(a, valueName, body) => ArrayFor(toStream(a), valueName, body)
//
//
////      case _ => Children(ir)
//      case ArraySort(a, l, r, comp) => ArraySort(streamify(a), l, r, comp)
//      case ToSet(a) => ToSet(streamify(a))
//      case ToDict(a) => ToDict(streamify(a))
//      case ArrayFold(a, zero, zn, an, body) => ArrayFold(streamify(a), zero, zn, an, body)
//      case ArrayFor(a, n, b) => ArrayFor(streamify(a), n, b)
//      case ArrayAgg(a, name, query) => ArrayAgg(streamify(a), name, streamify(query))
//      case ArrayRange(start, stop, step) => {
//
//        println("matched on....arrayrange")
//        StreamRange(streamify(start), streamify(stop), streamify(step))
//      }
//
//      case ArrayFilter(a, n, b) =>
//        if (a.typ.isInstanceOf[TStream]) a
//        else ArrayFilter(streamify(a), n, streamify(b))
//      case x: ApplyIR => streamify(x.explicitNode)
////      case _ if ir.typ.isInstanceOf[TStreamable] => unstreamify(ir)
//      case ToArray(a) =>
//        a.typ match {
//          case _: TArray => ToArray(streamify(a))
//          case _ => ir
//        }
//      case ToStream(a) =>
//        a.typ match {
//          case _: TStream => ToArray(a)
//          case _ => a
//        }
////      case _ =>
////        streamify(streamableNode) match {
////          case ToStream(a) if !a.typ.isInstanceOf[TStream] => a
////          case s => ToArray(s)
////        }
//
//      case _ if ir.children.length > 0 => {
//        println("Has children")
//        Copy(ir, Children(ir).map { case c: IR => toStream(c) })
//      }
//      case _ => toStream(ir) match {
//        // avoid creating ToArray(ToStream(array)
//        case ToStream(a) if !a.typ.isInstanceOf[TStream] => a
//        case stream if stream.typ.isInstanceOf[TStream] => ToArray(stream)
//      }
//
//    }
//    println(s"Resulting IR IS ${newIR}")
////    assert(newIR.typ == ir.typ)
//    newIR
//  }
//
//  private def toStream(ir: IR): IR = {
//    assert(ir.typ.isInstanceOf[TStreamable])
//    println(s"Calling toStreawm on ${ir}")
//    val streamWrappedIr = ir match {
//      case NA(t: TStreamable) => NA(TStream(t.elementType, t.required))
//      case MakeArray(xs, t) => MakeStream(xs, TStream(t.elementType, t.required))
//      case ArrayRange(x, y, z) => StreamRange(x, y, z)
//      case ArrayMap(a, n, b) => {
//        println(s"Running on ArrayMap of ${a}")
//        ArrayMap(streamify(a), n, b)
//      }
//      case ArrayZip(as, ns, b, behavior) => ArrayZip(as.map(streamify), ns, b, behavior)
////      case ArrayFilter(a, n, b) => ArrayFilter(streamify(a), n, b)
//      case ArrayFlatMap(a, n, b) => ArrayFlatMap(streamify(a), n, streamify(b))
//      case ArrayLeftJoinDistinct(l, r, ln, rn, c, j) => ArrayLeftJoinDistinct(streamify(l), streamify(r), ln, rn, c, j)
//      case ArrayScan(a, z, an, en, b) => ArrayScan(streamify(a), z, an, en, b)
//      case ArrayAggScan(a, n, q) => ArrayAggScan(streamify(a), n, q)
//      case RunAggScan(a, name, init, seq, res, sig) => RunAggScan(streamify(a), name, init, seq, res, sig)
//      case Let(n, v, b) => Let(n, v, streamify(b))
//      case If(c, t, e) => If(c, streamify(t), streamify(e))
//      case x: ReadPartition => x
//      case ir => {
//        if(ir.isInstanceOf[ToStream]) ir
//        else {
//          val r = ToStream(ir)
//          println(s"else: returning: ${r}")
//          r
//        }
//      }
//    }
//    println(s"resulting ir after toStream is ${streamWrappedIr}")
//    assert(streamWrappedIr.typ.isInstanceOf[TStream])
//    streamWrappedIr
//  }
//
//  private[this] def unstreamify(streamableNode: IR): IR = {
//    println(s"in unstreamify for ${streamableNode}")
//    streamableNode match {
//
//      case ToArray(a) =>
//        a.typ match {
//          case _: TArray => ToArray(streamify(a))
//          case _ => streamableNode
//        }
//      case ToStream(a) =>
//        a.typ match {
//          case _: TStream => ToArray(a)
//          case _ => a
//        }
//      case If(cond, cnsq, altr) =>
//        If(cond, unstreamify(cnsq), unstreamify(altr))
//      case Let(n, v, b) =>
//        Let(n, v, unstreamify(b))
//      case _ =>
//        streamify(streamableNode) match {
//          case ToStream(a) if !a.typ.isInstanceOf[TStream] => a
//          case s => ToArray(s)
//        }
//    }
//  }
//}

//
//private[this] def streamify(streamableNode: IR): IR = streamableNode match {
//  case _: MakeStream | _: StreamRange | _: ReadPartition => Copy(streamableNode, Children(streamableNode).map { case c: IR => apply(c) })
//
//  case MakeArray(args, t) => MakeStream(args.map(apply), TStream(t.elementType, t.required))
//  case ArrayMap(a, n, b) => {
//  if(a.typ.isInstanceOf[TStream]) {
//  println(s"type is TSTream ${a} b: ${b}")
//  streamableNode
//}else {
//  println(s"type not TSTream ${a} b: ${b}")
//  ArrayMap(apply(a), n, apply(b))
//}
//
//}
//
//  case ArrayZip(as, ns, b, behavior) => ArrayZip(as.map(streamify), ns, b, behavior)
//  case ArrayFilter(a, n, b) => ArrayFilter(apply(a), n, b)
//  case ArrayFlatMap(a, n, b) =>
//  if (a.typ.isInstanceOf[TStream] && b.typ.isInstanceOf[TStream]) streamableNode
//  else ArrayFlatMap(streamify(a), n, streamify(b))
//  case ArrayScan(a, zero, zn, an, body) =>
//  if (a.typ.isInstanceOf[TStream]) streamableNode
//  else ArrayScan(streamify(a), apply(zero), zn, an, apply(body))
//  case ToArray(a) =>
//  a.typ match {
//  case _: TStream => a
//  case _: TArray => streamify(a)
//  case _ => ToStream(apply(streamableNode))
//}
//  case ToStream(a) =>
//  a.typ match {
//  case _: TStream => a
//  case _ => ToStream(apply(a))
//}
//  case ArrayAggScan(a, n, q) => ArrayAggScan(apply(a), n, q)
//  case ArrayLeftJoinDistinct(l, r, ln, rn, keyf, joinf) =>
//  ArrayLeftJoinDistinct(streamify(l), streamify(r), ln, rn, apply(keyf), apply(joinf))
//  case Let(n, v, b) =>
//  Let(n, apply(v), streamify(b))
//  case RunAggScan(a, name, init, seq, res, sig) => RunAggScan(apply(a), name, init, seq, res, sig)
//  case If(c, t, e) => If(c, apply(t), apply(e))
//  case _ if streamableNode.children.length > 0 =>
//  ToStream(Copy(streamableNode, Children(streamableNode).map { case c: IR => apply(c) }))
//  case _ => ToStream(streamableNode)
//}

//  was only called from apply(
//  private[this] def unstreamify(streamableNode: IR): IR = streamableNode match {
//    case ToArray(a) =>
//      a.typ match {
//        case _: TArray => ToArray(streamify(a))
//        case _ => streamableNode
//      }
//    case ToStream(a) =>
//      a.typ match {
//        case _: TStream => ToArray(a)
//        case _ => a
//      }
//    case If(cond, cnsq, altr) =>
//      If(cond, unstreamify(cnsq), unstreamify(altr))
//    case Let(n, v, b) =>
//      Let(n, v, unstreamify(b))
//    case _ =>
//      streamify(streamableNode) match {
//        case ToStream(a) if !a.typ.isInstanceOf[TStream] => a
//        case s => ToArray(s)
//      }
//  }